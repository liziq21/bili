// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'network_article_search_result.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$NetworkArticleSearchResult {

 int get categoryId; String get categoryName; String get commentUrl; String get desc; int get id; List<String> get imageUrls; int get isComment; bool get isFold; bool get isRk1; int get like; int get mid; int get pubTime; int get rankIndex; int get rankOffset; int get reply; int get spreadId; int get subType; int get templateId; HtmlTitle get title; String get version; int get view;
/// Create a copy of NetworkArticleSearchResult
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$NetworkArticleSearchResultCopyWith<NetworkArticleSearchResult> get copyWith => _$NetworkArticleSearchResultCopyWithImpl<NetworkArticleSearchResult>(this as NetworkArticleSearchResult, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is NetworkArticleSearchResult&&(identical(other.categoryId, categoryId) || other.categoryId == categoryId)&&(identical(other.categoryName, categoryName) || other.categoryName == categoryName)&&(identical(other.commentUrl, commentUrl) || other.commentUrl == commentUrl)&&(identical(other.desc, desc) || other.desc == desc)&&(identical(other.id, id) || other.id == id)&&const DeepCollectionEquality().equals(other.imageUrls, imageUrls)&&(identical(other.isComment, isComment) || other.isComment == isComment)&&(identical(other.isFold, isFold) || other.isFold == isFold)&&(identical(other.isRk1, isRk1) || other.isRk1 == isRk1)&&(identical(other.like, like) || other.like == like)&&(identical(other.mid, mid) || other.mid == mid)&&(identical(other.pubTime, pubTime) || other.pubTime == pubTime)&&(identical(other.rankIndex, rankIndex) || other.rankIndex == rankIndex)&&(identical(other.rankOffset, rankOffset) || other.rankOffset == rankOffset)&&(identical(other.reply, reply) || other.reply == reply)&&(identical(other.spreadId, spreadId) || other.spreadId == spreadId)&&(identical(other.subType, subType) || other.subType == subType)&&(identical(other.templateId, templateId) || other.templateId == templateId)&&(identical(other.title, title) || other.title == title)&&(identical(other.version, version) || other.version == version)&&(identical(other.view, view) || other.view == view));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,categoryId,categoryName,commentUrl,desc,id,const DeepCollectionEquality().hash(imageUrls),isComment,isFold,isRk1,like,mid,pubTime,rankIndex,rankOffset,reply,spreadId,subType,templateId,title,version,view]);

@override
String toString() {
  return 'NetworkArticleSearchResult(categoryId: $categoryId, categoryName: $categoryName, commentUrl: $commentUrl, desc: $desc, id: $id, imageUrls: $imageUrls, isComment: $isComment, isFold: $isFold, isRk1: $isRk1, like: $like, mid: $mid, pubTime: $pubTime, rankIndex: $rankIndex, rankOffset: $rankOffset, reply: $reply, spreadId: $spreadId, subType: $subType, templateId: $templateId, title: $title, version: $version, view: $view)';
}


}

/// @nodoc
abstract mixin class $NetworkArticleSearchResultCopyWith<$Res>  {
  factory $NetworkArticleSearchResultCopyWith(NetworkArticleSearchResult value, $Res Function(NetworkArticleSearchResult) _then) = _$NetworkArticleSearchResultCopyWithImpl;
@useResult
$Res call({
 int categoryId, String categoryName, String commentUrl, String desc, int id, List<String> imageUrls, int isComment, bool isFold, bool isRk1, int like, int mid, int pubTime, int rankIndex, int rankOffset, int reply, int spreadId, int subType, int templateId, HtmlTitle title, String version, int view
});


$HtmlTitleCopyWith<$Res> get title;

}
/// @nodoc
class _$NetworkArticleSearchResultCopyWithImpl<$Res>
    implements $NetworkArticleSearchResultCopyWith<$Res> {
  _$NetworkArticleSearchResultCopyWithImpl(this._self, this._then);

  final NetworkArticleSearchResult _self;
  final $Res Function(NetworkArticleSearchResult) _then;

/// Create a copy of NetworkArticleSearchResult
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? categoryId = null,Object? categoryName = null,Object? commentUrl = null,Object? desc = null,Object? id = null,Object? imageUrls = null,Object? isComment = null,Object? isFold = null,Object? isRk1 = null,Object? like = null,Object? mid = null,Object? pubTime = null,Object? rankIndex = null,Object? rankOffset = null,Object? reply = null,Object? spreadId = null,Object? subType = null,Object? templateId = null,Object? title = null,Object? version = null,Object? view = null,}) {
  return _then(_self.copyWith(
categoryId: null == categoryId ? _self.categoryId : categoryId // ignore: cast_nullable_to_non_nullable
as int,categoryName: null == categoryName ? _self.categoryName : categoryName // ignore: cast_nullable_to_non_nullable
as String,commentUrl: null == commentUrl ? _self.commentUrl : commentUrl // ignore: cast_nullable_to_non_nullable
as String,desc: null == desc ? _self.desc : desc // ignore: cast_nullable_to_non_nullable
as String,id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int,imageUrls: null == imageUrls ? _self.imageUrls : imageUrls // ignore: cast_nullable_to_non_nullable
as List<String>,isComment: null == isComment ? _self.isComment : isComment // ignore: cast_nullable_to_non_nullable
as int,isFold: null == isFold ? _self.isFold : isFold // ignore: cast_nullable_to_non_nullable
as bool,isRk1: null == isRk1 ? _self.isRk1 : isRk1 // ignore: cast_nullable_to_non_nullable
as bool,like: null == like ? _self.like : like // ignore: cast_nullable_to_non_nullable
as int,mid: null == mid ? _self.mid : mid // ignore: cast_nullable_to_non_nullable
as int,pubTime: null == pubTime ? _self.pubTime : pubTime // ignore: cast_nullable_to_non_nullable
as int,rankIndex: null == rankIndex ? _self.rankIndex : rankIndex // ignore: cast_nullable_to_non_nullable
as int,rankOffset: null == rankOffset ? _self.rankOffset : rankOffset // ignore: cast_nullable_to_non_nullable
as int,reply: null == reply ? _self.reply : reply // ignore: cast_nullable_to_non_nullable
as int,spreadId: null == spreadId ? _self.spreadId : spreadId // ignore: cast_nullable_to_non_nullable
as int,subType: null == subType ? _self.subType : subType // ignore: cast_nullable_to_non_nullable
as int,templateId: null == templateId ? _self.templateId : templateId // ignore: cast_nullable_to_non_nullable
as int,title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as HtmlTitle,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as String,view: null == view ? _self.view : view // ignore: cast_nullable_to_non_nullable
as int,
  ));
}
/// Create a copy of NetworkArticleSearchResult
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$HtmlTitleCopyWith<$Res> get title {
  
  return $HtmlTitleCopyWith<$Res>(_self.title, (value) {
    return _then(_self.copyWith(title: value));
  });
}
}



/// @nodoc

@JsonSerializable(fieldRename: .snake)
class _NetworkArticleSearchResult implements NetworkArticleSearchResult {
  const _NetworkArticleSearchResult({required this.categoryId, required this.categoryName, required this.commentUrl, required this.desc, required this.id, required final  List<String> imageUrls, required this.isComment, required this.isFold, required this.isRk1, required this.like, required this.mid, required this.pubTime, required this.rankIndex, required this.rankOffset, required this.reply, required this.spreadId, required this.subType, required this.templateId, required this.title, required this.version, required this.view}): _imageUrls = imageUrls;
  factory _NetworkArticleSearchResult.fromJson(Map<String, dynamic> json) => _$NetworkArticleSearchResultFromJson(json);

@override final  int categoryId;
@override final  String categoryName;
@override final  String commentUrl;
@override final  String desc;
@override final  int id;
 final  List<String> _imageUrls;
@override List<String> get imageUrls {
  if (_imageUrls is EqualUnmodifiableListView) return _imageUrls;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_imageUrls);
}

@override final  int isComment;
@override final  bool isFold;
@override final  bool isRk1;
@override final  int like;
@override final  int mid;
@override final  int pubTime;
@override final  int rankIndex;
@override final  int rankOffset;
@override final  int reply;
@override final  int spreadId;
@override final  int subType;
@override final  int templateId;
@override final  HtmlTitle title;
@override final  String version;
@override final  int view;

/// Create a copy of NetworkArticleSearchResult
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$NetworkArticleSearchResultCopyWith<_NetworkArticleSearchResult> get copyWith => __$NetworkArticleSearchResultCopyWithImpl<_NetworkArticleSearchResult>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _NetworkArticleSearchResult&&(identical(other.categoryId, categoryId) || other.categoryId == categoryId)&&(identical(other.categoryName, categoryName) || other.categoryName == categoryName)&&(identical(other.commentUrl, commentUrl) || other.commentUrl == commentUrl)&&(identical(other.desc, desc) || other.desc == desc)&&(identical(other.id, id) || other.id == id)&&const DeepCollectionEquality().equals(other._imageUrls, _imageUrls)&&(identical(other.isComment, isComment) || other.isComment == isComment)&&(identical(other.isFold, isFold) || other.isFold == isFold)&&(identical(other.isRk1, isRk1) || other.isRk1 == isRk1)&&(identical(other.like, like) || other.like == like)&&(identical(other.mid, mid) || other.mid == mid)&&(identical(other.pubTime, pubTime) || other.pubTime == pubTime)&&(identical(other.rankIndex, rankIndex) || other.rankIndex == rankIndex)&&(identical(other.rankOffset, rankOffset) || other.rankOffset == rankOffset)&&(identical(other.reply, reply) || other.reply == reply)&&(identical(other.spreadId, spreadId) || other.spreadId == spreadId)&&(identical(other.subType, subType) || other.subType == subType)&&(identical(other.templateId, templateId) || other.templateId == templateId)&&(identical(other.title, title) || other.title == title)&&(identical(other.version, version) || other.version == version)&&(identical(other.view, view) || other.view == view));
}

@JsonKey(includeFromJson: false, includeToJson: false)
@override
int get hashCode => Object.hashAll([runtimeType,categoryId,categoryName,commentUrl,desc,id,const DeepCollectionEquality().hash(_imageUrls),isComment,isFold,isRk1,like,mid,pubTime,rankIndex,rankOffset,reply,spreadId,subType,templateId,title,version,view]);

@override
String toString() {
  return 'NetworkArticleSearchResult(categoryId: $categoryId, categoryName: $categoryName, commentUrl: $commentUrl, desc: $desc, id: $id, imageUrls: $imageUrls, isComment: $isComment, isFold: $isFold, isRk1: $isRk1, like: $like, mid: $mid, pubTime: $pubTime, rankIndex: $rankIndex, rankOffset: $rankOffset, reply: $reply, spreadId: $spreadId, subType: $subType, templateId: $templateId, title: $title, version: $version, view: $view)';
}


}

/// @nodoc
abstract mixin class _$NetworkArticleSearchResultCopyWith<$Res> implements $NetworkArticleSearchResultCopyWith<$Res> {
  factory _$NetworkArticleSearchResultCopyWith(_NetworkArticleSearchResult value, $Res Function(_NetworkArticleSearchResult) _then) = __$NetworkArticleSearchResultCopyWithImpl;
@override @useResult
$Res call({
 int categoryId, String categoryName, String commentUrl, String desc, int id, List<String> imageUrls, int isComment, bool isFold, bool isRk1, int like, int mid, int pubTime, int rankIndex, int rankOffset, int reply, int spreadId, int subType, int templateId, HtmlTitle title, String version, int view
});


@override $HtmlTitleCopyWith<$Res> get title;

}
/// @nodoc
class __$NetworkArticleSearchResultCopyWithImpl<$Res>
    implements _$NetworkArticleSearchResultCopyWith<$Res> {
  __$NetworkArticleSearchResultCopyWithImpl(this._self, this._then);

  final _NetworkArticleSearchResult _self;
  final $Res Function(_NetworkArticleSearchResult) _then;

/// Create a copy of NetworkArticleSearchResult
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? categoryId = null,Object? categoryName = null,Object? commentUrl = null,Object? desc = null,Object? id = null,Object? imageUrls = null,Object? isComment = null,Object? isFold = null,Object? isRk1 = null,Object? like = null,Object? mid = null,Object? pubTime = null,Object? rankIndex = null,Object? rankOffset = null,Object? reply = null,Object? spreadId = null,Object? subType = null,Object? templateId = null,Object? title = null,Object? version = null,Object? view = null,}) {
  return _then(_NetworkArticleSearchResult(
categoryId: null == categoryId ? _self.categoryId : categoryId // ignore: cast_nullable_to_non_nullable
as int,categoryName: null == categoryName ? _self.categoryName : categoryName // ignore: cast_nullable_to_non_nullable
as String,commentUrl: null == commentUrl ? _self.commentUrl : commentUrl // ignore: cast_nullable_to_non_nullable
as String,desc: null == desc ? _self.desc : desc // ignore: cast_nullable_to_non_nullable
as String,id: null == id ? _self.id : id // ignore: cast_nullable_to_non_nullable
as int,imageUrls: null == imageUrls ? _self._imageUrls : imageUrls // ignore: cast_nullable_to_non_nullable
as List<String>,isComment: null == isComment ? _self.isComment : isComment // ignore: cast_nullable_to_non_nullable
as int,isFold: null == isFold ? _self.isFold : isFold // ignore: cast_nullable_to_non_nullable
as bool,isRk1: null == isRk1 ? _self.isRk1 : isRk1 // ignore: cast_nullable_to_non_nullable
as bool,like: null == like ? _self.like : like // ignore: cast_nullable_to_non_nullable
as int,mid: null == mid ? _self.mid : mid // ignore: cast_nullable_to_non_nullable
as int,pubTime: null == pubTime ? _self.pubTime : pubTime // ignore: cast_nullable_to_non_nullable
as int,rankIndex: null == rankIndex ? _self.rankIndex : rankIndex // ignore: cast_nullable_to_non_nullable
as int,rankOffset: null == rankOffset ? _self.rankOffset : rankOffset // ignore: cast_nullable_to_non_nullable
as int,reply: null == reply ? _self.reply : reply // ignore: cast_nullable_to_non_nullable
as int,spreadId: null == spreadId ? _self.spreadId : spreadId // ignore: cast_nullable_to_non_nullable
as int,subType: null == subType ? _self.subType : subType // ignore: cast_nullable_to_non_nullable
as int,templateId: null == templateId ? _self.templateId : templateId // ignore: cast_nullable_to_non_nullable
as int,title: null == title ? _self.title : title // ignore: cast_nullable_to_non_nullable
as HtmlTitle,version: null == version ? _self.version : version // ignore: cast_nullable_to_non_nullable
as String,view: null == view ? _self.view : view // ignore: cast_nullable_to_non_nullable
as int,
  ));
}

/// Create a copy of NetworkArticleSearchResult
/// with the given fields replaced by the non-null parameter values.
@override
@pragma('vm:prefer-inline')
$HtmlTitleCopyWith<$Res> get title {
  
  return $HtmlTitleCopyWith<$Res>(_self.title, (value) {
    return _then(_self.copyWith(title: value));
  });
}
}

// dart format on
